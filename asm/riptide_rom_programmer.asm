;                     /\         /\__
;                   // \       (  0 )_____/\            __
;                  // \ \     (vv          o|          /^v\
;                //    \ \   (vvvv  ___-----^        /^^/\vv\
;              //  /     \ \ |vvvvv/               /^^/    \v\
;             //  /       (\\/vvvv/              /^^/       \v\
;            //  /  /  \ (  /vvvv/              /^^/---(     \v\
;           //  /  /    \( /vvvv/----(O        /^^/           \v\
;          //  /  /  \  (/vvvv/               /^^/             \v|
;        //  /  /    \( vvvv/                /^^/               ||
;       //  /  /    (  vvvv/                 |^^|              //
;      //  / /    (  |vvvv|                  /^^/            //
;     //  / /   (    \vvvvv\          )-----/^^/           //
;    // / / (          \vvvvv\            /^^^/          //
;   /// /(               \vvvvv\        /^^^^/          //
;  ///(              )-----\vvvvv\    /^^^^/-----(      \\
; //(                        \vvvvv\/^^^^/               \\
;/(                            \vvvv^^^/                 //
;                                \vv^/         /        //
;                                             /<______//
;                                            <<<------/
;                                             \<
;                                              \
;**************************************************
;* RIPTIDE_ROM_PROGRAMMER.ASM      SOURCE FILE    *
;* Copyright (C) 2022 Esteban Looser-Rojas.       *
;* Contains tool to program I2C EEPROMs           *
;* For custom platform using RIPTIDE-III CPU      *
;**************************************************

;PLATFORM HAS 8KB ROM AND 8KB RAM.
;RAM RANGE IS $0000 TO $1FFF (IN DATA SPACE)
;ROM RANGE IS $0000 TO $0FFF (IN PROGRAM SPACE)

INCLUDE "RIPTIDE-III.INC"

;VARIABLES
RND_H	EQU $1FFF
RND_L	EQU $1FFE

SERIAL_NUM_BYTES_H	EQU $1FFD
SERIAL_NUM_BYTES_L	EQU $1FFC

I2C_NUM_BYTES_H	EQU $1FFB
I2C_NUM_BYTES_L	EQU $1FFA

I2C_ADDRESS2	EQU $1FF9
I2C_ADDRESS1	EQU $1FF8
I2C_ADDRESS0	EQU $1FF7

BYTES_REMAINING2	EQU $1FF6
BYTES_REMAINING1	EQU $1FF5
BYTES_REMAINING0	EQU $1FF4

;CONSTANTS
CMD_READ	EQU $01
CMD_WRITE	EQU $02

	ORG 0
	JMP INT_RESET
	RET	;INT_HSYNC
	RET ;INT_VSYNC
	RET	;INT_UART_RX
	RET	;INT_UART_TX
	RET	;INT_KB_RX
	RET	;INT_TIMER
	RET	;INT_I2C

INT_RESET
	XMIT `HIGH INTERRUPT_STATUS, ADDR_HIGH
	XMIT `LOW INTERRUPT_STATUS, ADDR_LOW
	XMIT $00, IO0, 0
	XMIT `HIGH INTERRUPT_CONTROL, ADDR_HIGH
	XMIT `LOW INTERRUPT_CONTROL, ADDR_LOW
	XMIT $00, IO0, 0
	JMP INIT

INIT
	XMIT $00, AUX
	XMIT $00, R1
	XMIT $00, R2
	XMIT $00, R3
	XMIT $00, R4
	XMIT $00, R5
	XMIT $00, R6
	XMIT $00, R11	;INITIALIZE REGISTERS

	XMIT `HIGH RND_L, ADDR_HIGH
	XMIT `LOW RND_L, ADDR_LOW
	XMIT $00, DATA0, 8
	XMIT `HIGH RND_H, ADDR_HIGH
	XMIT `LOW RND_H, ADDR_LOW
	XMIT $00, DATA0, 8

	JMP MAIN

;MODIFIES REGISTERS: AUX, R11, ADDR_HIGH, ADDR_LOW
SERIAL_GET_BYTE
; CHECK THAT UART IS READY
	XMIT `HIGH UART_STATUS, ADDR_HIGH
	XMIT `LOW UART_STATUS, ADDR_LOW
SGB_WAIT
	XMIT $01, AUX
	MOVE IO3, 1, R11 	;READ RX DONE BIT
	XOR R11, R11 			;INVERT RX DONE BIT
	NZT R11, SGB_WAIT	;IF TX NOT READY KEEP WAITING
	XMIT `LOW UART_DATA, ADDR_LOW
	MOVE IO0, 8, R11
	RET

;MODIFIES REGISTERS: AUX, R6, ADDR_HIGH, ADDR_LOW
SERIAL_SEND_BYTE
; CHECK THAT UART IS READY
	XMIT `HIGH UART_STATUS, ADDR_HIGH
	XMIT `LOW UART_STATUS, ADDR_LOW
SSB_WAIT
	XMIT $01, AUX
	MOVE IO2, 1, R6
	XOR R6, R6
	NZT R6, SSB_WAIT
	XMIT `LOW UART_DATA, ADDR_LOW
	MOVE R11, 8, IO0
	RET

;MODIFIES REGISTERS: AUX, R3, R4, R5, R6, R11, ADDR_HIGH, ADDR_LOW
SERIAL_GET_N_BYTES
;GET THE NUMBER OF BYTES
	XMIT `HIGH SERIAL_NUM_BYTES_H, ADDR_HIGH
	XMIT `LOW SERIAL_NUM_BYTES_H, ADDR_LOW
	MOVE DATA0, 8, R6
	XMIT `HIGH SERIAL_NUM_BYTES_L, ADDR_HIGH
	XMIT `LOW SERIAL_NUM_BYTES_L, ADDR_LOW
	MOVE DATA0, 8, R5
;SET STARTING ADDRESS IN MEMORY
	XMIT $00, R4
	XMIT $00, R3
;LOOP N TIMES
	NZT R6, SGNB_LOOP
	NZT R5, SGNB_LOOP
	RET
SGNB_LOOP
;GET BYTE
	XMIT `HIGH SERIAL_GET_BYTE, AUX
	CALL SERIAL_GET_BYTE
;WRITE BYTE
	MOVE R4, ADDR_HIGH
	MOVE R3, ADDR_LOW
	MOVE R11, 8, DATA0
;INCREMENT DATA ADDRESS
	XMIT $01, AUX
	ADD R3, R3
	MOVE OVF, AUX
	ADD R4, R4
;DECREMENT COUNTER
	XMIT $FF, AUX
	ADD R5, R5
	ADD OVF, AUX
	ADD R6, R6
;CHECK IF ZERO
	NZT R6, SGNB_LOOP
	NZT R5, SGNB_LOOP
	RET

;MODIFIES REGISTERS: AUX, R2, R3, R4, R5, R6, R11, ADDR_HIGH, ADDR_LOW
SERIAL_SEND_N_BYTES
;GET THE NUMBER OF BYTES
	XMIT `HIGH SERIAL_NUM_BYTES_H, ADDR_HIGH
	XMIT `LOW SERIAL_NUM_BYTES_H, ADDR_LOW
	MOVE DATA0, 8, R5
	XMIT `HIGH SERIAL_NUM_BYTES_L, ADDR_HIGH
	XMIT `LOW SERIAL_NUM_BYTES_L, ADDR_LOW
	MOVE DATA0, 8, R4
;SET STARTING ADDRESS IN MEMORY
	XMIT $00, R3
	XMIT $00, R2
;LOOP N TIMES
	NZT R5, SSNB_LOOP
	NZT R4, SSNB_LOOP
	RET
SSNB_LOOP
;GET BYTE
	MOVE R3, ADDR_HIGH
	MOVE R2, ADDR_LOW
	MOVE DATA0, 8, R11
;WRITE BYTE
	XMIT `HIGH SERIAL_SEND_BYTE, AUX
	CALL SERIAL_SEND_BYTE
;INCREMENT DATA ADDRESS
	XMIT $01, AUX
	ADD R2, R2
	MOVE OVF, AUX
	ADD R3, R3
;DECREMENT COUNTER
	XMIT $FF, AUX
	ADD R4, R4
	ADD OVF, AUX
	ADD R5, R5
;CHECK IF ZERO
	NZT R5, SSNB_LOOP
	NZT R4, SSNB_LOOP
	RET

;MODIFIES REGISTERS: AUX, ADDR_HIGH, ADDR_LOW
I2C_START
	XMIT `HIGH I2C_STATUS, ADDR_HIGH
	XMIT `LOW I2C_STATUS, ADDR_LOW
	XMIT $01, AUX
	MOVE AUX, 8, IO0	;WRITE TO I2C_STATUS CLEARS READY FLAG
	MOVE IO0, 8, AUX	;DUMMY READ BEFORE CHECKING STATUS BECAUSE I2C MODULE HAS 2 CYCLE LATENCY
IS_LOOP
	MOVE IO6, 1, AUX
	NZT AUX, IS_DONE
	JMP IS_LOOP
IS_DONE
	RET

;MODIFIES REGISTERS: AUX, ADDR_HIGH, ADDR_LOW
I2C_STOP
	XMIT `HIGH I2C_STATUS, ADDR_HIGH
	XMIT `LOW I2C_STATUS, ADDR_LOW
	XMIT $02, AUX
	MOVE AUX, 8, IO0	;WRITE TO I2C_STATUS CLEARS READY FLAG
	MOVE IO0, 8, AUX	;DUMMY READ BEFORE CHECKING STATUS BECAUSE I2C MODULE HAS 2 CYCLE LATENCY
ISTOP_LOOP
	MOVE IO6, 1, AUX
	NZT AUX, ISTOP_DONE
	JMP ISTOP_LOOP
ISTOP_DONE
	RET

;MODIFIES REGISTERS: AUX, R11, ADDR_HIGH, ADDR_LOW
I2C_GET_BYTE
	XMIT `HIGH I2C_STATUS, ADDR_HIGH
	XMIT `LOW I2C_STATUS, ADDR_LOW
	XMIT $14, AUX	;READ REQ + ACK
	MOVE AUX, 8, IO0	;WRITE TO I2C_STATUS CLEARS READY FLAG
	MOVE IO0, 8, AUX	;DUMMY READ BEFORE CHECKING STATUS BECAUSE I2C MODULE HAS 2 CYCLE LATENCY
IGET_LOOP
	MOVE IO6, 1, AUX
	NZT AUX, IGET_DONE
	JMP IGET_LOOP
IGET_DONE
	XMIT `HIGH I2C_DATA, ADDR_HIGH
	XMIT `LOW I2C_DATA, ADDR_LOW
	MOVE IO0, 8, R11
	MOVE IO0, 8, R11	;NOT A TYPO, I2C MODULE HAS 2 CYCLE LATENCY
	RET

;MODIFIES REGISTERS: AUX, R11, ADDR_HIGH, ADDR_LOW
I2C_GET_BYTE_NAK
	XMIT `HIGH I2C_STATUS, ADDR_HIGH
	XMIT `LOW I2C_STATUS, ADDR_LOW
	XMIT $04, AUX	;READ REQ
	MOVE AUX, 8, IO0	;WRITE TO I2C_STATUS CLEARS READY FLAG
	MOVE IO0, 8, AUX	;DUMMY READ BEFORE CHECKING STATUS BECAUSE I2C MODULE HAS 2 CYCLE LATENCY
IGETBN_LOOP
	MOVE IO6, 1, AUX
	NZT AUX, IGETBN_DONE
	JMP IGETBN_LOOP
IGETBN_DONE
	XMIT `HIGH I2C_DATA, ADDR_HIGH
	XMIT `LOW I2C_DATA, ADDR_LOW
	MOVE IO0, 8, R11
	MOVE IO0, 8, R11	;NOT A TYPO, I2C MODULE HAS 2 CYCLE LATENCY
	RET

;MODIFIES REGISTERS: AUX, ADDR_HIGH, ADDR_LOW
I2C_SEND_BYTE
	XMIT `HIGH I2C_DATA, ADDR_HIGH
	XMIT `LOW I2C_DATA, ADDR_LOW
	MOVE R11, 8, IO0	;WRITE TO I2C_DATA CLEARS READY FLAG
	XMIT `HIGH I2C_STATUS, ADDR_HIGH
	XMIT `LOW I2C_STATUS, ADDR_LOW
	XMIT $08, AUX
	MOVE AUX, 8, IO0
ISENDB_LOOP
	MOVE IO6, 1, AUX
	NZT AUX, ISENDB_DONE
	JMP ISENDB_LOOP
ISENDB_DONE
	RET

;MODIFIES REGISTERS: AUX, R3, R4, R5, R6, R11, ADDR_HIGH, ADDR_LOW
I2C_GET_N_BYTES
;GET THE NUMBER OF BYTES
	XMIT `HIGH I2C_NUM_BYTES_H, ADDR_HIGH
	XMIT `LOW I2C_NUM_BYTES_H, ADDR_LOW
	MOVE DATA0, 8, R6
	XMIT `HIGH I2C_NUM_BYTES_L, ADDR_HIGH
	XMIT `LOW I2C_NUM_BYTES_L, ADDR_LOW
	MOVE DATA0, 8, R5
;SET STARTING ADDRESS IN MEMORY
	XMIT $00, R4
	XMIT $00, R3
;LOOP N TIMES
	NZT R6, IGNB_LOOP
	NZT R5, IGNB_LOOP
	RET
IGNB_LOOP
;GET BYTE
	XMIT `HIGH I2C_GET_BYTE, AUX
	CALL I2C_GET_BYTE
;WRITE BYTE
	MOVE R4, ADDR_HIGH
	MOVE R3, ADDR_LOW
	MOVE R11, 8, DATA0
;INCREMENT DATA ADDRESS
	XMIT $01, AUX
	ADD R3, R3
	MOVE OVF, AUX
	ADD R4, R4
;DECREMENT COUNTER
	XMIT $FF, AUX
	ADD R5, R5
	ADD OVF, AUX
	ADD R6, R6
;CHECK IF ZERO
	NZT R6, IGNB_LOOP
	NZT R5, IGNB_LOOP
	RET

;MODIFIES REGISTERS: AUX, R3, R4, R5, R6, R11, ADDR_HIGH, ADDR_LOW
I2C_SEND_N_BYTES
;GET THE NUMBER OF BYTES
	XMIT `HIGH I2C_NUM_BYTES_H, ADDR_HIGH
	XMIT `LOW I2C_NUM_BYTES_H, ADDR_LOW
	MOVE DATA0, 8, R6
	XMIT `HIGH I2C_NUM_BYTES_L, ADDR_HIGH
	XMIT `LOW I2C_NUM_BYTES_L, ADDR_LOW
	MOVE DATA0, 8, R5
;SET STARTING ADDRESS IN MEMORY
	XMIT $00, R4
	XMIT $00, R3
;LOOP N TIMES
	NZT R6, ISNB_LOOP
	NZT R5, ISNB_LOOP
	RET
ISNB_LOOP
;GET BYTE
	MOVE R4, ADDR_HIGH
	MOVE R3, ADDR_LOW
	MOVE DATA0, 8, R11
;WRITE BYTE
	XMIT `HIGH I2C_SEND_BYTE, AUX
	CALL I2C_SEND_BYTE
;INCREMENT DATA ADDRESS
	XMIT $01, AUX
	ADD R3, R3
	MOVE OVF, AUX
	ADD R4, R4
;DECREMENT COUNTER
	XMIT $FF, AUX
	ADD R5, R5
	ADD OVF, AUX
	ADD R6, R6
;CHECK IF ZERO
	NZT R6, ISNB_LOOP
	NZT R5, ISNB_LOOP
	RET

;MODIFIES REGISTERS: AUX, R11, ADDR_HIGH, ADDR_LOW
RND_GET_WORD
	XMIT `HIGH RND_L, ADDR_HIGH
	XMIT `LOW RND_L, ADDR_LOW
	XMIT $01, AUX
	XOR DATA0, 1, AUX
	XOR DATA7, 1, AUX	;COMPUTE NEW MSB AND PUT IT IN AUX
	XMIT `HIGH RND_H, ADDR_HIGH
	XMIT `LOW RND_H, ADDR_LOW
	MOVE DATA0, 1, R11	;STORE LSB OF RND_H IN R11
	MOVE DATA1, 7, DATA0	;RIGHT SHIFT RND_H
	MOVE AUX, 1, DATA7	;STORE NEW MSB IN RND_H
	XMIT `HIGH RND_L, ADDR_HIGH
	XMIT `LOW RND_L, ADDR_LOW
	MOVE DATA1, 7, DATA0	;RIGHT SHIFT RND_L
	MOVE R11, 1, DATA7	;STORE LSB OF RND_H IN RND_L
	RET

;MODIFIES REGISTERS: AUX, R6, R11, ADDR_HIGH, ADDR_LOW
RND_BUILD_BYTE
	XMIT $08, R6
	JMP RND_BUILD_LOOP
RND_BUILD_WORD
	XMIT $10, R6
RND_BUILD_LOOP
	XMIT `HIGH RND_GET_WORD, AUX
	CALL RND_GET_WORD
	XMIT $FF, AUX
	ADD R6, R6
	NZT R6, RND_BUILD_LOOP
	RET

MAIN
;WAIT FOR PING ($AA55)
	XMIT `HIGH SERIAL_GET_BYTE, AUX
	CALL SERIAL_GET_BYTE
	XMIT $AA, AUX
	XOR R11, AUX
	NZT AUX, MAIN
	XMIT `HIGH SERIAL_GET_BYTE, AUX
	CALL SERIAL_GET_BYTE
	XMIT $55, AUX
	XOR R11, AUX
	NZT AUX, MAIN
;ACK PING
	XMIT $55, R11
	XMIT `HIGH SERIAL_SEND_BYTE, AUX
	CALL SERIAL_SEND_BYTE
	XMIT $AA, R11
	XMIT `HIGH SERIAL_SEND_BYTE, AUX
	CALL SERIAL_SEND_BYTE
;SEND MEMORY SIZE
	XMIT $02, R11
	XMIT `HIGH SERIAL_SEND_BYTE, AUX
	CALL SERIAL_SEND_BYTE
	XMIT $00, R11
	XMIT `HIGH SERIAL_SEND_BYTE, AUX
	CALL SERIAL_SEND_BYTE
	XMIT $00, R11
	XMIT `HIGH SERIAL_SEND_BYTE, AUX
	CALL SERIAL_SEND_BYTE
;GET COMMAND
M_COMMAND
	XMIT `HIGH SERIAL_GET_BYTE, AUX
	CALL SERIAL_GET_BYTE
	XMIT CMD_READ, AUX
	XOR R11, AUX
	NZT AUX, M_NOT_READ
	XMIT `HIGH COM_READ, AUX
	CALL COM_READ
	JMP M_COMMAND
M_NOT_READ
	;XMIT `HIGH SERIAL_GET_BYTE, AUX
	;CALL SERIAL_GET_BYTE
	XMIT CMD_WRITE, AUX
	XOR R11, AUX
	NZT AUX, M_NOT_WRITE
	XMIT `HIGH COM_WRITE, AUX
	CALL COM_WRITE
	JMP M_COMMAND
M_NOT_WRITE
	XMIT $00, R11
	XMIT `HIGH SERIAL_SEND_BYTE, AUX
	CALL SERIAL_SEND_BYTE
	XMIT $00, R11
	XMIT `HIGH SERIAL_SEND_BYTE, AUX
	CALL SERIAL_SEND_BYTE
	XMIT $00, R11
	XMIT `HIGH SERIAL_SEND_BYTE, AUX
	CALL SERIAL_SEND_BYTE
	JMP MAIN

;MODIFIES REGISTERS: AUX, R2, R3, R4, R5, R6, R11, R12, R13, R14, ADDR_HIGH, ADDR_LOW
COM_READ
;GET NUM BYTES AND RESPOND TO REQUEST
	XMIT `HIGH SERIAL_GET_BYTE, AUX
	CALL SERIAL_GET_BYTE
	XMIT `HIGH BYTES_REMAINING2, ADDR_HIGH
	XMIT `LOW BYTES_REMAINING2, ADDR_LOW
	MOVE R11, 8, DATA0
	XMIT `HIGH SERIAL_SEND_BYTE, AUX
	CALL SERIAL_SEND_BYTE
	XMIT `HIGH SERIAL_GET_BYTE, AUX
	CALL SERIAL_GET_BYTE
	XMIT `HIGH BYTES_REMAINING1, ADDR_HIGH
	XMIT `LOW BYTES_REMAINING1, ADDR_LOW
	MOVE R11, 8, DATA0
	XMIT `HIGH SERIAL_SEND_BYTE, AUX
	CALL SERIAL_SEND_BYTE
	XMIT `HIGH SERIAL_GET_BYTE, AUX
	CALL SERIAL_GET_BYTE
	XMIT `HIGH BYTES_REMAINING0, ADDR_HIGH
	XMIT `LOW BYTES_REMAINING0, ADDR_LOW
	MOVE R11, 8, DATA0
	XMIT `HIGH SERIAL_SEND_BYTE, AUX
	CALL SERIAL_SEND_BYTE
;START I2C
	XMIT `HIGH I2C_START, AUX
	CALL I2C_START
;SET I2C ADDRESS
	XMIT $00, AUX
	XMIT `HIGH I2C_ADDRESS0, ADDR_HIGH
	XMIT `LOW I2C_ADDRESS0, ADDR_LOW
	MOVE AUX, 8, DATA0
	XMIT `HIGH I2C_ADDRESS1, ADDR_HIGH
	XMIT `LOW I2C_ADDRESS1, ADDR_LOW
	MOVE AUX, 8, DATA0
	XMIT `HIGH I2C_ADDRESS2, ADDR_HIGH
	XMIT `LOW I2C_ADDRESS2, ADDR_LOW
	MOVE AUX, 8, DATA0
	XMIT `HIGH CAT_SET_ADDRESS_WRITE, AUX
	CALL CAT_SET_ADDRESS_WRITE	;DUMMY WRITE TO SET ADDRESS
	XMIT `HIGH I2C_START, AUX
	CALL I2C_START	;REPEATED START
	XMIT `HIGH CAT_SET_ADDRESS_READ, AUX
	CALL CAT_SET_ADDRESS_READ	;DEVICE ADDRESS FOR READING
COMR_LOOP
;STORE BYTES REMAINING IN R14, R13, R12
	XMIT `HIGH BYTES_REMAINING2, ADDR_HIGH
	XMIT `LOW BYTES_REMAINING2, ADDR_LOW
	MOVE DATA0, 8, R14
	XMIT `HIGH BYTES_REMAINING1, ADDR_HIGH
	XMIT `LOW BYTES_REMAINING1, ADDR_LOW
	MOVE DATA0, 8, R13
	XMIT `HIGH BYTES_REMAINING0, ADDR_HIGH
	XMIT `LOW BYTES_REMAINING0, ADDR_LOW
	MOVE DATA0, 8, R12
;STORE BUFFER SIZE IN R4, R3, R2
	XMIT $00, R4
	XMIT $1C, R3
	XMIT $00, R2
;MAKE BYTES REMAINING NEGATIVE
	XMIT $FF, AUX
	XOR R14, R14
	XOR R13, R13
	XOR R12, R12
	XMIT $01, AUX
	ADD R12, R12
	MOVE OVF, AUX
	ADD R13, R13
	MOVE OVF, AUX
	ADD R14, R14
;SUBTRACT BYTES REMAINING FROM BUFFER SIZE
	MOVE R12, AUX
	ADD R2, R2
	MOVE OVF, AUX
	ADD R3, R3
	MOVE OVF, AUX
	ADD R4, R4
	MOVE R13, AUX
	ADD R3, R3
	MOVE OVF, AUX
	ADD R4, R4
	MOVE R14, AUX
	ADD R4, R4
;CHECK IF NUMBER OF BYTES IS GREATER THAN BUFFER SIZE
	XMIT $80, AUX
	AND R4, AUX
	NZT AUX, COMR_GREATER
;STORE BYTES REMAINING IN R13, R12
	XMIT `HIGH BYTES_REMAINING1, ADDR_HIGH
	XMIT `LOW BYTES_REMAINING1, ADDR_LOW
	MOVE DATA0, 8, R13
	XMIT `HIGH BYTES_REMAINING0, ADDR_HIGH
	XMIT `LOW BYTES_REMAINING0, ADDR_LOW
	MOVE DATA0, 8, R12
	JMP COMR_TRANSFER
COMR_GREATER
;STORE MAX TRANSFER SIZE IN R13, R12
	XMIT $1C, R13
	XMIT $00, R12
COMR_TRANSFER
;SET NUM BYTES TO TRANSFER
	XMIT `HIGH I2C_NUM_BYTES_H, ADDR_HIGH
	XMIT `LOW I2C_NUM_BYTES_H, ADDR_LOW
	MOVE R13, 8, DATA0
	XMIT `HIGH I2C_NUM_BYTES_L, ADDR_HIGH
	XMIT `LOW I2C_NUM_BYTES_L, ADDR_LOW
	MOVE R12, 8, DATA0
	XMIT `HIGH SERIAL_NUM_BYTES_H, ADDR_HIGH
	XMIT `LOW SERIAL_NUM_BYTES_H, ADDR_LOW
	MOVE R13, 8, DATA0
	XMIT `HIGH SERIAL_NUM_BYTES_L, ADDR_HIGH
	XMIT `LOW SERIAL_NUM_BYTES_L, ADDR_LOW
	MOVE R12, 8, DATA0
;READ BYTES
	XMIT `HIGH I2C_GET_N_BYTES, AUX
	CALL I2C_GET_N_BYTES
;SEND BYTES
	XMIT `HIGH SERIAL_SEND_N_BYTES, AUX
	CALL SERIAL_SEND_N_BYTES
;STORE BYTES REMANING IN R4, R3, R2
	XMIT `HIGH BYTES_REMAINING2, ADDR_HIGH
	XMIT `LOW BYTES_REMAINING2, ADDR_LOW
	MOVE DATA0, 8, R4
	XMIT `HIGH BYTES_REMAINING1, ADDR_HIGH
	XMIT `LOW BYTES_REMAINING1, ADDR_LOW
	MOVE DATA0, 8, R3
	XMIT `HIGH BYTES_REMAINING0, ADDR_HIGH
	XMIT `LOW BYTES_REMAINING0, ADDR_LOW
	MOVE DATA0, 8, R2
;MAKE NUMBER OF BYTES TRANSFERED NEGATIVE
	XMIT $00, R14
	XMIT $FF, AUX
	XOR R14, R14
	XOR R13, R13
	XOR R12, R12
	XMIT $01, AUX
	ADD R12, R12
	MOVE OVF, AUX
	ADD R13, R13
	MOVE OVF, AUX
	ADD R14, R14
;SUBTRACT BYTES TRANSFERED FROM BYTES REMAINING
	MOVE R12, AUX
	ADD R2, R2
	MOVE OVF, AUX
	ADD R3, R3
	MOVE OVF, AUX
	ADD R4, R4
	MOVE R13, AUX
	ADD R3, R3
	MOVE OVF, AUX
	ADD R4, R4
	MOVE R14, AUX
	ADD R4, R4
;UPDATE NUMBER OF BYTES REMAINING
	XMIT `HIGH BYTES_REMAINING2, ADDR_HIGH
	XMIT `LOW BYTES_REMAINING2, ADDR_LOW
	MOVE R4, 8, DATA0
	XMIT `HIGH BYTES_REMAINING1, ADDR_HIGH
	XMIT `LOW BYTES_REMAINING1, ADDR_LOW
	MOVE R3, 8, DATA0
	XMIT `HIGH BYTES_REMAINING0, ADDR_HIGH
	XMIT `LOW BYTES_REMAINING0, ADDR_LOW
	MOVE R2, 8, DATA0
;CHECK IF BYTES REMAINING IS ZERO
	NZT R4, COMR_LOOP
	NZT R3, COMR_LOOP
	NZT R2, COMR_LOOP
;DUMMY READ WITH NAK
	XMIT `HIGH I2C_GET_BYTE_NAK, AUX
	CALL I2C_GET_BYTE_NAK
;STOP I2C
	XMIT `HIGH I2C_STOP, AUX
	CALL I2C_STOP
	RET

	ORG $0200

COM_WRITE
;GET NUM BYTES
	XMIT `HIGH SERIAL_GET_BYTE, AUX
	CALL SERIAL_GET_BYTE
	XMIT `HIGH BYTES_REMAINING2, ADDR_HIGH
	XMIT `LOW BYTES_REMAINING2, ADDR_LOW
	MOVE R11, 8, DATA0
	XMIT `HIGH SERIAL_GET_BYTE, AUX
	CALL SERIAL_GET_BYTE
	XMIT `HIGH BYTES_REMAINING1, ADDR_HIGH
	XMIT `LOW BYTES_REMAINING1, ADDR_LOW
	MOVE R11, 8, DATA0
	XMIT `HIGH SERIAL_GET_BYTE, AUX
	CALL SERIAL_GET_BYTE
	XMIT `HIGH BYTES_REMAINING0, ADDR_HIGH
	XMIT `LOW BYTES_REMAINING0, ADDR_LOW
	MOVE R11, 8, DATA0
;SET I2C ADDRESS
	XMIT $00, AUX
	XMIT `HIGH I2C_ADDRESS0, ADDR_HIGH
	XMIT `LOW I2C_ADDRESS0, ADDR_LOW
	MOVE AUX, 8, DATA0
	XMIT `HIGH I2C_ADDRESS1, ADDR_HIGH
	XMIT `LOW I2C_ADDRESS1, ADDR_LOW
	MOVE AUX, 8, DATA0
	XMIT `HIGH I2C_ADDRESS2, ADDR_HIGH
	XMIT `LOW I2C_ADDRESS2, ADDR_LOW
	MOVE AUX, 8, DATA0
COMW_LOOP
;STORE BYTES REMAINING IN R14, R13, R12
	XMIT `HIGH BYTES_REMAINING2, ADDR_HIGH
	XMIT `LOW BYTES_REMAINING2, ADDR_LOW
	MOVE DATA0, 8, R14
	XMIT `HIGH BYTES_REMAINING1, ADDR_HIGH
	XMIT `LOW BYTES_REMAINING1, ADDR_LOW
	MOVE DATA0, 8, R13
	XMIT `HIGH BYTES_REMAINING0, ADDR_HIGH
	XMIT `LOW BYTES_REMAINING0, ADDR_LOW
	MOVE DATA0, 8, R12
;STORE BUFFER SIZE IN R4, R3, R2
	XMIT $00, R4
	XMIT $1C, R3
	XMIT $00, R2
;MAKE BYTES REMAINING NEGATIVE
	XMIT $FF, AUX
	XOR R14, R14
	XOR R13, R13
	XOR R12, R12
	XMIT $01, AUX
	ADD R12, R12
	MOVE OVF, AUX
	ADD R13, R13
	MOVE OVF, AUX
	ADD R14, R14
;SUBTRACT BYTES REMAINING FROM BUFFER SIZE
	MOVE R12, AUX
	ADD R2, R2
	MOVE OVF, AUX
	ADD R3, R3
	MOVE OVF, AUX
	ADD R4, R4
	MOVE R13, AUX
	ADD R3, R3
	MOVE OVF, AUX
	ADD R4, R4
	MOVE R14, AUX
	ADD R4, R4
;CHECK IF NUMBER OF BYTES IS GREATER THAN BUFFER SIZE
	XMIT $80, AUX
	AND R4, AUX
	NZT AUX, COMW_GREATER
;STORE BYTES REMAINING IN R13, R12
	XMIT `HIGH BYTES_REMAINING1, ADDR_HIGH
	XMIT `LOW BYTES_REMAINING1, ADDR_LOW
	MOVE DATA0, 8, R13
	XMIT `HIGH BYTES_REMAINING0, ADDR_HIGH
	XMIT `LOW BYTES_REMAINING0, ADDR_LOW
	MOVE DATA0, 8, R12
	JMP COMW_TRANSFER
COMW_GREATER
;STORE MAX TRANSFER SIZE IN R13, R12
	XMIT $1C, R13
	XMIT $00, R12
COMW_TRANSFER
;REQUEST BYTES
	XMIT $00, R11
	XMIT `HIGH SERIAL_SEND_BYTE, AUX
	CALL SERIAL_SEND_BYTE
	MOVE R13, R11
	XMIT `HIGH SERIAL_SEND_BYTE, AUX
	CALL SERIAL_SEND_BYTE
	MOVE R12, R11
	XMIT `HIGH SERIAL_SEND_BYTE, AUX
	CALL SERIAL_SEND_BYTE
;SET NUM BYTES TO TRANSFER
	XMIT `HIGH I2C_NUM_BYTES_H, ADDR_HIGH
	XMIT `LOW I2C_NUM_BYTES_H, ADDR_LOW
	MOVE R13, 8, DATA0
	XMIT `HIGH I2C_NUM_BYTES_L, ADDR_HIGH
	XMIT `LOW I2C_NUM_BYTES_L, ADDR_LOW
	MOVE R12, 8, DATA0
	XMIT `HIGH SERIAL_NUM_BYTES_H, ADDR_HIGH
	XMIT `LOW SERIAL_NUM_BYTES_H, ADDR_LOW
	MOVE R13, 8, DATA0
	XMIT `HIGH SERIAL_NUM_BYTES_L, ADDR_HIGH
	XMIT `LOW SERIAL_NUM_BYTES_L, ADDR_LOW
	MOVE R12, 8, DATA0
;READ BYTES
	XMIT `HIGH SERIAL_GET_N_BYTES, AUX
	CALL SERIAL_GET_N_BYTES
;SEND BYTES
	XMIT `HIGH CAT_WRITE_N_BYTES, AUX
	CALL CAT_WRITE_N_BYTES
;STORE BYTES REMANING IN R4, R3, R2
	XMIT `HIGH BYTES_REMAINING2, ADDR_HIGH
	XMIT `LOW BYTES_REMAINING2, ADDR_LOW
	MOVE DATA0, 8, R4
	XMIT `HIGH BYTES_REMAINING1, ADDR_HIGH
	XMIT `LOW BYTES_REMAINING1, ADDR_LOW
	MOVE DATA0, 8, R3
	XMIT `HIGH BYTES_REMAINING0, ADDR_HIGH
	XMIT `LOW BYTES_REMAINING0, ADDR_LOW
	MOVE DATA0, 8, R2
;STORE BYTES TRANSFERED IN R14, R13, R12
	XMIT $00, R14	;MOST SIGNIFICANT BYTE IS ALWAYS 0 BECAUSE THE BUFFER SIZE IS < 64KB
	XMIT `HIGH I2C_NUM_BYTES_H, ADDR_HIGH	;THIS IS A HACK, I2C_NUM_BYTES IS NOT MODIFIED BY OTHER SUBROUTINES
	XMIT `LOW I2C_NUM_BYTES_H, ADDR_LOW
	MOVE DATA0, 8, R13
	XMIT `HIGH I2C_NUM_BYTES_L, ADDR_HIGH
	XMIT `LOW I2C_NUM_BYTES_L, ADDR_LOW
	MOVE DATA0, 8, R12
;MAKE NUMBER OF BYTES TRANSFERED NEGATIVE
	XMIT $FF, AUX
	XOR R14, R14
	XOR R13, R13
	XOR R12, R12
	XMIT $01, AUX
	ADD R12, R12
	MOVE OVF, AUX
	ADD R13, R13
	MOVE OVF, AUX
	ADD R14, R14
;SUBTRACT BYTES TRANSFERED FROM BYTES REMAINING
	MOVE R12, AUX
	ADD R2, R2
	MOVE OVF, AUX
	ADD R3, R3
	MOVE OVF, AUX
	ADD R4, R4
	MOVE R13, AUX
	ADD R3, R3
	MOVE OVF, AUX
	ADD R4, R4
	MOVE R14, AUX
	ADD R4, R4
;UPDATE NUMBER OF BYTES REMAINING
	XMIT `HIGH BYTES_REMAINING2, ADDR_HIGH
	XMIT `LOW BYTES_REMAINING2, ADDR_LOW
	MOVE R4, 8, DATA0
	XMIT `HIGH BYTES_REMAINING1, ADDR_HIGH
	XMIT `LOW BYTES_REMAINING1, ADDR_LOW
	MOVE R3, 8, DATA0
	XMIT `HIGH BYTES_REMAINING0, ADDR_HIGH
	XMIT `LOW BYTES_REMAINING0, ADDR_LOW
	MOVE R2, 8, DATA0
;CHECK IF BYTES REMAINING IS ZERO
	NZT R4, COMW_LOOP
	NZT R3, COMW_LOOP
	NZT R2, COMW_LOOP
	RET

;MODIFIES REGISTERS: AUX, R11, ADDR_HIGH, ADDR_LOW
CAT_SET_ADDRESS_READ
	XMIT `HIGH I2C_ADDRESS2, ADDR_HIGH
	XMIT `LOW I2C_ADDRESS2, ADDR_LOW
	MOVE DATA7, 8, R11
	XMIT %1010 1001, AUX
	XOR R11, R11
	XMIT `HIGH I2C_SEND_BYTE, AUX
	CALL I2C_SEND_BYTE
	RET

;MODIFIES REGISTERS: AUX, R11, ADDR_HIGH, ADDR_LOW
CAT_SET_ADDRESS_WRITE
	XMIT `HIGH I2C_ADDRESS2, ADDR_HIGH
	XMIT `LOW I2C_ADDRESS2, ADDR_LOW
	MOVE DATA7, 8, R11
	XMIT %1010 1000, AUX
	XOR R11, R11
	XMIT `HIGH I2C_SEND_BYTE, AUX
	CALL I2C_SEND_BYTE
	XMIT `HIGH I2C_ADDRESS1, ADDR_HIGH
	XMIT `LOW I2C_ADDRESS1, ADDR_LOW
	MOVE DATA0, 8, R11
	XMIT `HIGH I2C_SEND_BYTE, AUX
	CALL I2C_SEND_BYTE
	XMIT `HIGH I2C_ADDRESS0, ADDR_HIGH
	XMIT `LOW I2C_ADDRESS0, ADDR_LOW
	MOVE DATA0, 8, R11
	XMIT `HIGH I2C_SEND_BYTE, AUX
	CALL I2C_SEND_BYTE
	RET

;MODIFIES REGISTERS: AUX, R3, R4, R5, R6, R11, R12, R13, R14, ADDR_HIGH, ADDR_LOW
CAT_WRITE_N_BYTES
;GET THE NUMBER OF BYTES
	XMIT `HIGH I2C_NUM_BYTES_H, ADDR_HIGH
	XMIT `LOW I2C_NUM_BYTES_H, ADDR_LOW
	MOVE DATA0, 8, R6
	XMIT `HIGH I2C_NUM_BYTES_L, ADDR_HIGH
	XMIT `LOW I2C_NUM_BYTES_L, ADDR_LOW
	MOVE DATA0, 8, R5
;GET I2C ADDRESS
	XMIT `HIGH I2C_ADDRESS2, ADDR_HIGH
	XMIT `LOW I2C_ADDRESS2, ADDR_LOW
	MOVE DATA0, 8, R14
	XMIT `HIGH I2C_ADDRESS1, ADDR_HIGH
	XMIT `LOW I2C_ADDRESS1, ADDR_LOW
	MOVE DATA0, 8, R13
	XMIT `HIGH I2C_ADDRESS0, ADDR_HIGH
	XMIT `LOW I2C_ADDRESS0, ADDR_LOW
	MOVE DATA0, 8, R12
;SET STARTING ADDRESS IN MEMORY
	XMIT $00, R4
	XMIT $00, R3
; LOOP N TIMES
	NZT R6, CWNB_WAIT
	NZT R5, CWNB_WAIT
	RET
CWNB_LOOP
;GET BYTE
	MOVE R4, ADDR_HIGH
	MOVE R3, ADDR_LOW
	MOVE DATA0, 8, R11
;WRITE BYTE
	XMIT `HIGH I2C_SEND_BYTE, AUX
	CALL I2C_SEND_BYTE
;INCREMENT DATA ADDRESS
	XMIT $01, AUX
	ADD R3, R3
	MOVE OVF, AUX
	ADD R4, R4
;INCREMENT I2C ADDRESS
	XMIT $01, AUX
	ADD R12, R12
	MOVE OVF, AUX
	ADD R13, R13
	MOVE OVF, AUX
	ADD R14, R14
;DECREMENT COUNTER
	XMIT $FF, AUX
	ADD R5, R5
	ADD OVF, AUX
	ADD R6, R6
;CHECK IF COUNTER IS ZERO
	NZT R5, CWNB_ND
	NZT R6, CWNB_ND
;UPDATE I2C ADDRESS
	XMIT `HIGH I2C_ADDRESS2, ADDR_HIGH
	XMIT `LOW I2C_ADDRESS2, ADDR_LOW
	MOVE R14, 8, DATA0
	XMIT `HIGH I2C_ADDRESS1, ADDR_HIGH
	XMIT `LOW I2C_ADDRESS1, ADDR_LOW
	MOVE R13, 8, DATA0
	XMIT `HIGH I2C_ADDRESS0, ADDR_HIGH
	XMIT `LOW I2C_ADDRESS0, ADDR_LOW
	MOVE R12, 8, DATA0
;STOP I2C
	XMIT `HIGH I2C_STOP, AUX
	CALL I2C_STOP
	RET
CWNB_ND
	NZT R12, CWNB_LOOP
CWNB_PAGE
;UPDATE I2C ADDRESS
	XMIT `HIGH I2C_ADDRESS2, ADDR_HIGH
	XMIT `LOW I2C_ADDRESS2, ADDR_LOW
	MOVE R14, 8, DATA0
	XMIT `HIGH I2C_ADDRESS1, ADDR_HIGH
	XMIT `LOW I2C_ADDRESS1, ADDR_LOW
	MOVE R13, 8, DATA0
	XMIT `HIGH I2C_ADDRESS0, ADDR_HIGH
	XMIT `LOW I2C_ADDRESS0, ADDR_LOW
	MOVE R12, 8, DATA0
;STOP I2C
	XMIT `HIGH I2C_STOP, AUX
	CALL I2C_STOP
CWNB_WAIT
;START I2C
	XMIT `HIGH I2C_START, AUX
	CALL I2C_START
;SET WRITE ADDRESS
	XMIT `HIGH CAT_SET_ADDRESS_WRITE, AUX
	CALL CAT_SET_ADDRESS_WRITE
;CHECK FOR ACK
	XMIT `HIGH I2C_STATUS, ADDR_HIGH
	XMIT `LOW I2C_STATUS, ADDR_LOW
	MOVE IO5, 1, AUX
	NZT AUX, CWNB_LOOP
	JMP CWNB_WAIT

	ORG $0FFF	;PAD FILE TO 4K WORDS
	JMP INIT